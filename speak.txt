As we can see from entry_pgdir, we have the first 4 MB of the RAM available for us to use mapped starting from virtual address 0xf0000000 to 0xf03fffff
We'd like to start allocating memory for us to use for dynamicly allocated data structures, but we have several problems:

we don't have something like a malloc for us to use to "dynamically allocate stuff on the heap". This means we'll need to create our own allocator.
The kernel code and data is already present in RAM 
We need to keep track of which addresses have already been allocated, and which ones are free.
All of those problem are addressed by the boot_alloc function. This will be our "temporary" memory allocator which we'll use to start allocating data structures dynamically. It is temporary because it can manage only the first 4MB of RAM
memory addresses returned by boot_alloc will have to be page aligned (divisible by 4096). This is because the x86 hardware mandates page alignment for the page directory.
using a data structure to keep track of which (physical) page frames are allocated and which ones are free. Each page frame will have its own PageInfo struct that will also store some metadata, and those stucts will form a linked list. The amount of page frames we'll be managing depends on how much RAM we have in the computer, so we'll use boot_alloc to allocate an array of PageInfo proportional to the amount of RAM available, and will call this array struct PageInfo *pages.

The head of the linked list is struct PageInfo *page_free_list and what we'll need to do next is to add all the free frames to this linked list. When adding the free page frames, it is important to first add the free page frames from the original 4MB region managed by boot_alloc because although all others page frames are marked as "free", we have no way of accessing them as they are not yet mapped to virtual addresses.
Once we are done with this, we will no longer need to use boot_alloc in order to allocate memory because page_free_list will now contain all the frames in the original 4MB region that were not yet allocated by boot_alloc. In order to effectively use page_free_list, we'll create a function called page_alloc that "mark" a page frame as in use by popping it off the page_free_list.
The way we can access the data stored in a page frame directly is through the page2kva macro. 
let's say we popped a struct PageInfo from the page_free_list (let's call it pp). Wwe clculate the physical address by finding what index pp is in the pages array and multiply it by the page size: (pp - pages)*4096.
But the processor can't address physical address directly, how knowing the physical address help us? Each page frame in the original 4MB region is mapped at virtual address located at an offset of 0xf0000000.
mem_init tells us to do is map the (physical) RAM addresses from 0x00000000 - 0x0fffffff into the virtual addresses 0xf0000000-0xffffffff
256 MB is 268435456 bytes is 65536 page frames (divide by 4096). Each frame occupies 4 bytes in a page table entry. So this means we'll need 65536 * 4 = 262,144 bytes to store all the page tables of these mappings. This looks like it can fit +1. If want to know how many page tables this will require: 65536 (total frames) / 1024 (frames mapped in each page table) = 64 page tables.

The metadata about page frames (physical pages) is stored in:
struct PageInfo {
        // Next page on the free list.
        struct PageInfo *pp_link;
        // pp_ref is the count of pointers (usually in page table entries)
        uint16_t pp_ref;
};
and we can allocate an array of these as following (see explanation about boot_alloc in the next section):
pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo));
thus, each page frame (of physical memory) will have a corresponding metadata entry in this array. 
Helper  functions:
// convert from a page to its physical address (use pa2page to do vice versa)
static inline physaddr_t page2pa(struct PageInfo *pp) and 
// same as page2pa but returns the kernel virtual address instead.
static inline void* page2kva(struct PageInfo *pp)

BOOT ALLOC
boot_alloc is a "memory allocator", somewhat similar in its operation to the linux brk() system call. except unlike brk(), it operates on physical pages (page frames). As already mentioned, the virtual addresses 0xf0000000 to 0xf03fffff are mapped to physical addresses 0x00000000 to 0x003fffff, and this is the address range that boot_alloc will be supposed to manage (technically, it will manage all the addresses above the last address used for storing the kenel data. The first such address is 0xf0118bd0).

boot_alloc keeps track of what is allocated and what is not allocated with the static char *nextfree variable. addresses that are lower than nextfree are considered allocated, and addresses equal or above nextfree (up to 0xf03fffff) are considered unallocated. As a consequence, nextfree points to the first free address.
So "Allocating 1 page" means adding 4096 to the address nextfree is storing 

 When we get a request to allocate, say 3 pages, we will store the current value of nextfree into result, add 3*4096 to nextfree and will return result. this way, the memory region between result and nextfree is reserved to whomever called boot_alloc

the addresses of nextfree and result must be divisible by 4096 (page size). Thus, the first address returned by this function is 0xf0119000).


PAGE INIT
The purpose of this function is to create and initialize a data structure that will keep track of the metadata of all free page frames (physical pages) in the system. A linked list can be a good choice for this because it's very efficient to add to and to remove from. We already have an aray that contains the metadata of all the page frames struct PageInfo *pages, so we'll use the elements of this array and add all the free page frames into the linked list represented by static struct PageInfo *page_free_list
How do we know which page frames are free in the extended memory (physical memory above 1M)?
As previously noted, boot_alloc keeps track of all the allocated memory starting from 0xf0119000, and if we call boot_alloc(0), we'll get the first address which has not been allocated by boot_alloc. Because boot_alloc returns virtual addresses, and we are interested in the physical address of the page frame, we'll need to use the PADDR macro to convert it to the physical address, and then divide it by the page size PGSIZE (4096) to get the appropriate index into the pages array.

Kernel is located at the start of EXTPHYSMEM so the code has to find out where it ends and skip those pages as well.


The global variable page_free_list points to the head of a linked list of the free pages. Therefore, allocating a page means simply popping the head of the linked list, assigning the next element to be the new head, and returning the popped element. Freeing a page means adding an extra element to the linked list.
