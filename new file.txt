Conventional operating systems are great at abstracting memory away from the application programmer to give the illusion that there is an infinite amount available.
To avoid complications, the JOS kernel simply assumes that there is 256MB of memory.
To put it in big picture terms, we keep track of memeory in some kernel data structure which chunks of memory are currently in use, and which are not. 
we’ll think of memory in 4Kb chunks, which we call pages. Every page will be marked as either in use, or not in use. For example, in our data structure, we’ll have that page 0 (bytes [0, 4096[) is in use, page 1 (bytes [4096, 8192[) isn’t, and so on.
We keep track of all the memory pages in a global array pages. For each physical page, there is a corresponding struct PageInfo in this array (i.e. pages[0] refers to page 0, pages[1] refers to page 1, and so on). Note that the pages array is a C pointer only because we dynamically allocate it instead of statically allocating it.
A struct PageInfo keeps track of two things: a free list link, and a reference count. The convention is as follows: if the reference count is 0, then the page is free and is on the free list.
That is because virtual memory allows you to map two different virtual pages to the same physical page (i.e. two different page table entries contain the same address field). This is known as a memory mapping. Therefore, we need to wait for any mapping to the same physical page from all the page tables to be removed until we can safely declare the physical page to be “not in use”. To do that, every time we map the physical page in a page table, we increase the reference count, and every time we remove the mapping from a page table, we decrease the count. Whenever the count hits 0, the physical page is considered “not in use”.
Along with the pages array, we have a pointer page_free_list that points into the pages array at the first free page. The rest of the free list is traversed using the pages’ pp_link pointer.
So in general, how do we use the pages array? Well, if you want to know if page n is in use, you access pages[n]. Or, if you just want a free page, you take the one pointed to by page_free_list (and update page_free_list to point to the subsequent item on the list).
We take all the available memory, divide it up into 4Kb chunks, and keep track of which pages are in use and which aren’t, giving out pages to other subsystems on demand.
Virtual memory is the decoupling between the addresses stored in a program and physical addresses.
when your CPU is instructed by your program to, for example, store 0 at address 0xFF203E76, it doesn’t go to address 0xFF203E76 directly. Instead, it sends 0xFF203E76 through the MMU (the hardware component that manages virtual memory) to get the physical address to which 0xFF203E76 is mapped to and iti will store 0 there.
The neat thing is that the MMU relies on data structures of a predefined format set up by the operating system to perform this translation… In other words, the operating system decides which (virtual) addresses a program can access, and where these (virtual) addresses map to in (physical) memory. This is also known as an address space.

In the second phase of address transformation, the 80386 transforms a linear address into a physical address. This phase of address transformation implements the basic features needed for page-oriented virtual-memory systems and page-level protection.
The page-translation step is optional. Page translation is in effect only when the PG bit of CR0 is set. This bit is typically set by the operating system during software initialization. The PG bit must be set if the operating system is to implement multiple virtual 8086 tasks, page-oriented protection, or page-oriented virtual memory.
A page frame is a 4K-byte unit of contiguous addresses of physical memory. Pages begin onbyte boundaries and are fixed in size.
A linear address refers indirectly to a physical address by specifying a page table, a page within that table, and an offset within that page.
 The processor converts the DIR, PAGE, and OFFSET fields of a linear address into the physical address by consulting two levels of page tables. The addressing mechanism uses the DIR field as an index into a page directory, uses the PAGE field as an index into the page table determined by the page directory, and uses the OFFSET field to address a byte within the page determined by the page table.
A page table is simply an array of 32-bit page specifiers. A page table is itself a page, and therefore contains 4 Kilobytes of memory or at most 1K 32-bit entries.
Two levels of tables are used to address a page of memory. At the higher level is a page directory. The page directory addresses up to 1K page tables of the second level. A page table of the second level addresses up to 1K pages. All the tables addressed by one page directory, therefore, can address 1M pages (2^(20)). Because each page contains 4K bytes 2^(12) bytes), the tables of one page directory can span the entire physical address space of the 80386 (2^(20) times 2^(12) = 2^(32)).
The physical address of the current page directory is stored in the CPU register CR3, also called the page directory base register (PDBR). Memory management software has the option of using one page directory for all tasks, one page directory for each task, or some combination of the two. 
Entries in either level of page tables have the same format as follows:
The page frame address specifies the physical starting address of a page. Because pages are located on 4K boundaries, the low-order 12 bits are always zero. In a page directory, the page frame address is the address of a page table. In a second-level page table, the page frame address is the address of the page frame that contains the desired memory operand.
The Present bit indicates whether a page table entry can be used in address translation. P=1 indicates that the entry can be used.
When P=0 in either level of page tables, the entry is not valid for address translation, and the rest of the entry is available for software use; none of the other bits in the entry is tested by the hardware.
If P=0 in either level of page tables when an attempt is made to use a page-table entry for address translation, the processor signals a page exception. In software systems that support paged virtual memory, the page-not-present exception handler can bring the required page into physical memory. The instruction that caused the exception can then be reexecuted.
Note that there is no present bit for the page directory itself. The page directory may be not-present while the associated task is suspended, but the operating system must ensure that the page directory indicated by the CR3 image in the TSS is present in physical memory before the task is dispatched .
These bits provide data about page usage in both levels of the page tables. With the exception of the dirty bit in a page directory entry, these bits are set by the hardware; however, the processor does not clear any of these bits.
The processor sets the corresponding accessed bits in both levels of page tables to one before a read or write operation to a page.
The processor sets the dirty bit in the second-level page table to one before a write to an address covered by that page table entry. The dirty bit in directory entries is undefined.
An operating system that supports paged virtual memory can use these bits to determine what pages to eliminate from physical memory when the demand for memory exceeds the physical memory available. The operating system is responsible for testing and clearing these bits.
 Read/Write and User/Supervisor Bits: These bits are not used for address translation, but are used for page-level protection, which the processor performs at the same time as address translation .
F0or greatest efficiency in address translation, the processor stores the most recently used page-table data in an on-chip cache. Only if the necessary paging information is not in the cache must both levels of page tables be referenced.
The existence of the page-translation cache is invisible to applications programmers but not to systems programmers; operating-system programmers must flush the cache whenever the page tables are changed. The page-translation cache can be flushed by either of two methods:
By reloading CR3 with a MOV instruction; for example:
MOV CR3, EAX
By performing a task switch to a TSS that has a different CR3 image than the current TSS .
 instead of indexing the whole memory with one big array like we did with the pages array, it uses 1024 page tables that each track 1024 pages, and a page directory that tracks all the page tables (for a total of 1024 * 1024 = 1,048,576 pages, the maximum amount addressable by a 32-bit address). For example, to access page 0, you would access page table 0 in the page directory at index 0, and then page 0 in that page table at index 0.
The data structures in question are the page directory and the page tables. The format of a page directory or page table entry is also well defined by the hardware.
Now assume that the operating system has just finished setting up a new address space (i.e. a page directory and page tables are set up and sitting in memory).
we need to load the (physical) address of our page directory into a system register called CR3. 
Page  Directory / Page table: It’s basically an address to the page table or to a page of memory, respectively, along with a bunch of flags.
Programs are compiled to instructions that reference virtual addresses. Whenever the CPU needs to access these addresses, it sends the address through the MMU which traverses the page directory and page table structures that were carefully set up by the operating system to find the corresponding physical page to which the address refers. The CPU then performs its memory access there.
When the CPU sends a virtual address through the MMU while executing a given user program, the MMU indexes into the page directory or the subsequent page table. 
However, if the Present bit of the page table or page directory entry  is turned off, the CPU will throw an exception, transferring control back to the operating system. The operating system then looks in the CR2 special register to find the address that the user program failed to access; if the address is inside a page that the operating system had previously moved to disk due to heavy memory pressure, then the operating system will:
Allocate a new physical page (with page_alloc()).
Copy the contents of the page stored on disk into this newly allocated page.
Modify the page table entry to point to this newly allocated page.
Transfer control back to the user program, which will repeat the same instruction, but this time successfully accessing the physical memory page.
If the CPU accessed physical memory directly, there would be no way for the operating system to copy the contents of a memory page to disk in order to reuse the memory page for something else, and bring back the contents of the original memory page only when the program needs it.
page_insert(), which is used to insert a physical page into a page directory/page table structure.
page_insert() takes four arguments: pgdir a pointer to a page directory in memory, pp a pointer to a struct PageInfo which corresponds to the physical page that is to be inserted, va a virtual address to which the physical page is to be mapped, and perm a set of flags
We use the convenient function pgdir_walk() to give us a pointer to the page table entry for the page in which va points
pgdir_walk() essentially traverses the page directory and page tables in software the same way that the MMU does it in hardware. The third argument, 1, instructs pgdir_walk() to create a new empty page table if it doesn’t exist yet. Thus, if it needs to allocate a new page for a page table but there is no memory pages left, it will return NULL.
Then, We increment the reference count of the physical page.
We remove any physical page that would already be mapped at va. That is to say, if the Present bit is set in the page table entry for va, we check the address stored in the entry, decrement the reference count of the physical page pointed to by the address in the entry, and unset the Present bit in the page table entry. The net effect is that any mapped physical page is removed from the address space.
Finally, we rewrite the page table entry with pp’s physical address, and the right set of flags. page2pa() is a tiny function which calculates the physical address of a given struct PageInfo based on its offset from the beginning of the struct PageInfo array pages. It is defined in kern/pmap.h.



boot_alloc is a "memory allocator", somewhat similar in its operation to the linux brk() system call. except unlike brk(), it operates on physical pages (page frames). As already mentioned, the virtual addresses 0xf0000000 to 0xf03fffff are mapped to physical addresses 0x00000000 to 0x003fffff, and this is the address range that boot_alloc will be supposed to manage (technically, it will manage all the addresses above the last address used for storing the kenel data. The first such address is 0xf0118bd0). The function signature of boot_alloc suggests that we should operate on virtual addresses instead of physical ones, but since there is a one-to-one correspondence betwwen them, it shouldn't get too messy to talk about only virtual addresses (although let's not forget that it's actually physical memory being allocated).
boot_alloc keeps track of what is allocated and what is not allocated with the static char *nextfree variable. addresses that are lower than nextfree are considered allocated, and addresses equal or above nextfree (up to 0xf03fffff) are considered unallocated. As a consequence, nextfree points to the first free address.
So "Allocating 1 page" means adding 4096 to the address nextfree is storing. When we get a request to allocate, say 3 pages, we will store the current value of nextfree into result, add 3*4096 to nextfree and will return result. this way, the memory region between result and nextfree is reserved to whomever called boot_alloc (notice that in this case, nextfree - result= 3*4096).
